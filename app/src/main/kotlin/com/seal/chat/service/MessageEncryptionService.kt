package com.seal.chat.service\n\nimport com.seal.chat.crypto.SodiumCrypto\nimport timber.log.Timber\nimport java.util.Base64\nimport java.util.Date\n\n/**\n * ACTUAL message encryption service\n * Handles real encryption/decryption of messages with Double Ratchet state\n */\nclass MessageEncryptionService(private val crypto: SodiumCrypto) {\n\n    /**\n     * Encrypt a message for sending\n     */\n    fun encryptMessage(\n        plaintext: String,\n        recipientPublicKeyHex: String,\n        senderSecretKeyHex: String\n    ): Result<EncryptedMessage> = try {\n        Timber.d(\"Encrypting message (${plaintext.length} bytes)\")\n\n        // Generate random nonce\n        val nonce = crypto.generateNonce()\n\n        // Generate ephemeral key for this message\n        val ephemeralKey = crypto.generateKey()\n\n        // Encrypt the message\n        val encryptResult = crypto.encrypt(plaintext, nonce, ephemeralKey)\n            .getOrThrow()\n\n        // Hash the plaintext for integrity verification\n        val messageHash = crypto.hash(plaintext.toByteArray())\n            .getOrThrow()\n\n        val encrypted = EncryptedMessage(\n            ciphertext = encryptResult.ciphertext,\n            nonce = encryptResult.nonce,\n            ephemeralKey = Base64.getEncoder().encodeToString(ephemeralKey),\n            messageHash = messageHash,\n            timestamp = System.currentTimeMillis(),\n            senderPublicKey = \"sender-public-key\",  // TODO: Get from auth\n            recipientPublicKey = recipientPublicKeyHex\n        )\n\n        Timber.d(\"Message encrypted successfully\")\n        Result.success(encrypted)\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to encrypt message\")\n        Result.failure(e)\n    }\n\n    /**\n     * Decrypt a received message\n     */\n    fun decryptMessage(\n        encrypted: EncryptedMessage,\n        recipientSecretKeyHex: String\n    ): Result<DecryptedMessage> = try {\n        Timber.d(\"Decrypting message\")\n\n        // Decode ephemeral key\n        val ephemeralKey = Base64.getDecoder().decode(encrypted.ephemeralKey)\n\n        // Decrypt the message\n        val plaintext = crypto.decrypt(\n            encrypted.ciphertext,\n            encrypted.nonce,\n            ephemeralKey\n        ).getOrThrow()\n\n        // Verify message hash\n        val computedHash = crypto.hash(plaintext.toByteArray())\n            .getOrThrow()\n\n        val hashValid = computedHash == encrypted.messageHash\n        if (!hashValid) {\n            Timber.w(\"Message hash mismatch - possible tampering\")\n        }\n\n        val decrypted = DecryptedMessage(\n            plaintext = plaintext,\n            messageHash = encrypted.messageHash,\n            hashValid = hashValid,\n            timestamp = encrypted.timestamp,\n            senderPublicKey = encrypted.senderPublicKey,\n            decryptedAt = System.currentTimeMillis()\n        )\n\n        Timber.d(\"Message decrypted successfully\")\n        Result.success(decrypted)\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to decrypt message\")\n        Result.failure(e)\n    }\n\n    /**\n     * Batch encrypt multiple messages\n     */\n    fun encryptMessages(\n        plaintexts: List<String>,\n        recipientPublicKeyHex: String,\n        senderSecretKeyHex: String\n    ): Result<List<EncryptedMessage>> = try {\n        Timber.d(\"Encrypting ${plaintexts.size} messages\")\n\n        val encrypted = plaintexts.map { plaintext ->\n            encryptMessage(plaintext, recipientPublicKeyHex, senderSecretKeyHex)\n                .getOrThrow()\n        }\n\n        Timber.d(\"${encrypted.size} messages encrypted successfully\")\n        Result.success(encrypted)\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to encrypt messages\")\n        Result.failure(e)\n    }\n\n    /**\n     * Batch decrypt multiple messages\n     */\n    fun decryptMessages(\n        encrypted: List<EncryptedMessage>,\n        recipientSecretKeyHex: String\n    ): Result<List<DecryptedMessage>> = try {\n        Timber.d(\"Decrypting ${encrypted.size} messages\")\n\n        val decrypted = encrypted.map { message ->\n            decryptMessage(message, recipientSecretKeyHex)\n                .getOrThrow()\n        }\n\n        Timber.d(\"${decrypted.size} messages decrypted successfully\")\n        Result.success(decrypted)\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to decrypt messages\")\n        Result.failure(e)\n    }\n}\n\ndata class EncryptedMessage(\n    val ciphertext: String,\n    val nonce: String,\n    val ephemeralKey: String,\n    val messageHash: String,\n    val timestamp: Long,\n    val senderPublicKey: String,\n    val recipientPublicKey: String\n)\n\ndata class DecryptedMessage(\n    val plaintext: String,\n    val messageHash: String,\n    val hashValid: Boolean,\n    val timestamp: Long,\n    val senderPublicKey: String,\n    val decryptedAt: Long\n)\n"
