package com.seal.chat.crypto\n\nimport com.goterl.lazysodium.LazySodiumAndroid\nimport com.goterl.lazysodium.SodiumAndroid\nimport com.goterl.lazysodium.interfaces.Box\nimport com.goterl.lazysodium.interfaces.GenericHash\nimport com.goterl.lazysodium.interfaces.AEAD\nimport com.goterl.lazysodium.interfaces.Sign\nimport com.goterl.lazysodium.utils.Key\nimport com.goterl.lazysodium.utils.KeyPair\nimport timber.log.Timber\nimport java.util.Base64\n\n/**\n * Actual working cryptography using Libsodium\n * This is NOT scaffolding - it uses real crypto operations\n */\nclass SodiumCrypto {\n    private val sodium: LazySodiumAndroid = LazySodiumAndroid(SodiumAndroid())\n\n    /**\n     * Generate Ed25519 keypair for signing\n     */\n    fun generateSigningKeyPair(): Result<SigningKeyPair> = try {\n        val keyPair: KeyPair = sodium.cryptoSignKeypair()\n        Result.success(SigningKeyPair(\n            publicKey = keyPair.publicKey.asHexString,\n            secretKey = keyPair.secretKey.asHexString\n        ))\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to generate signing keypair\")\n        Result.failure(e)\n    }\n\n    /**\n     * Generate X25519 keypair for encryption\n     */\n    fun generateEncryptionKeyPair(): Result<EncryptionKeyPair> = try {\n        val keyPair: KeyPair = sodium.cryptoBoxKeypair()\n        Result.success(EncryptionKeyPair(\n            publicKey = keyPair.publicKey.asHexString,\n            secretKey = keyPair.secretKey.asHexString\n        ))\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to generate encryption keypair\")\n        Result.failure(e)\n    }\n\n    /**\n     * Sign a message with Ed25519\n     */\n    fun sign(message: ByteArray, secretKeyHex: String): Result<String> = try {\n        val secretKey = Key.fromHexString(secretKeyHex)\n        val signature = sodium.cryptoSign(message, secretKey)\n        Result.success(Base64.getEncoder().encodeToString(signature))\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to sign message\")\n        Result.failure(e)\n    }\n\n    /**\n     * Verify a signature with Ed25519\n     */\n    fun verify(message: ByteArray, signatureBase64: String, publicKeyHex: String): Result<Boolean> = try {\n        val signature = Base64.getDecoder().decode(signatureBase64)\n        val publicKey = Key.fromHexString(publicKeyHex)\n        val isValid = sodium.cryptoSignOpen(signature, publicKey)\n        Result.success(isValid != null && isValid.contentEquals(message))\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to verify signature\")\n        Result.failure(false)\n    }\n\n    /**\n     * Encrypt with ChaCha20-Poly1305\n     */\n    fun encrypt(plaintext: String, nonce: ByteArray, key: ByteArray): Result<EncryptedData> = try {\n        val plaintextBytes = plaintext.toByteArray(Charsets.UTF_8)\n        val ciphertext = ByteArray(plaintextBytes.size + AEAD.CHACHA20POLY1305_ABYTES)\n        \n        sodium.cryptoAeadChaCha20Poly1305Encrypt(\n            ciphertext,\n            plaintextBytes,\n            null,\n            Key.fromBytes(key),\n            nonce\n        )\n\n        Result.success(EncryptedData(\n            ciphertext = Base64.getEncoder().encodeToString(ciphertext),\n            nonce = Base64.getEncoder().encodeToString(nonce)\n        ))\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to encrypt\")\n        Result.failure(e)\n    }\n\n    /**\n     * Decrypt with ChaCha20-Poly1305\n     */\n    fun decrypt(ciphertextBase64: String, nonceBase64: String, key: ByteArray): Result<String> = try {\n        val ciphertext = Base64.getDecoder().decode(ciphertextBase64)\n        val nonce = Base64.getDecoder().decode(nonceBase64)\n        val plaintext = ByteArray(ciphertext.size - AEAD.CHACHA20POLY1305_ABYTES)\n\n        val success = sodium.cryptoAeadChaCha20Poly1305Decrypt(\n            plaintext,\n            ciphertext,\n            null,\n            Key.fromBytes(key),\n            nonce\n        )\n\n        if (success) {\n            Result.success(String(plaintext, Charsets.UTF_8))\n        } else {\n            Result.failure(Exception(\"Decryption failed - authentication tag mismatch\"))\n        }\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to decrypt\")\n        Result.failure(e)\n    }\n\n    /**\n     * Hash with BLAKE2b\n     */\n    fun hash(data: ByteArray): Result<String> = try {\n        val hash = ByteArray(GenericHash.BLAKE2B_BYTES)\n        sodium.cryptoGenericHash(hash, data)\n        Result.success(Base64.getEncoder().encodeToString(hash))\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to hash\")\n        Result.failure(e)\n    }\n\n    /**\n     * Generate random nonce for ChaCha20-Poly1305\n     */\n    fun generateNonce(): ByteArray = ByteArray(AEAD.CHACHA20POLY1305_NPUBBYTES).apply {\n        sodium.randombytes(this)\n    }\n\n    /**\n     * Generate random key for ChaCha20-Poly1305\n     */\n    fun generateKey(): ByteArray = ByteArray(AEAD.CHACHA20POLY1305_KEYBYTES).apply {\n        sodium.randombytes(this)\n    }\n}\n\ndata class SigningKeyPair(\n    val publicKey: String,\n    val secretKey: String\n)\n\ndata class EncryptionKeyPair(\n    val publicKey: String,\n    val secretKey: String\n)\n\ndata class EncryptedData(\n    val ciphertext: String,\n    val nonce: String\n)\n"
