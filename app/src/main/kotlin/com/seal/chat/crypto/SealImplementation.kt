package com.seal.chat.crypto\n\nimport timber.log.Timber\nimport java.util.Date\n\n/**\n * ACTUAL working SEAL implementation\n * Creates cryptographic proofs of messages that cannot be denied\n */\nclass SealImplementation(private val crypto: SodiumCrypto) {\n\n    /**\n     * Create a SEAL from messages\n     * Returns a cryptographic proof that these messages existed at this time\n     */\n    fun createSeal(\n        messages: List<String>,\n        creatorPublicKeyHex: String,\n        creatorSecretKeyHex: String\n    ): Result<Seal> = try {\n        Timber.d(\"Creating SEAL from ${messages.size} messages\")\n\n        // Step 1: Hash each message\n        val messageHashes = messages.map { message ->\n            crypto.hash(message.toByteArray()).getOrThrow()\n        }\n\n        // Step 2: Build Merkle tree\n        val merkleRoot = buildMerkleTree(messageHashes)\n            ?: throw Exception(\"Failed to build Merkle tree\")\n\n        // Step 3: Create SEAL metadata\n        val sealMetadata = SealMetadata(\n            messageCount = messages.size,\n            merkleRoot = merkleRoot,\n            timestamp = System.currentTimeMillis(),\n            messageHashes = messageHashes\n        )\n\n        // Step 4: Sign the SEAL metadata\n        val metadataJson = sealMetadata.toJson()\n        val signature = crypto.sign(metadataJson.toByteArray(), creatorSecretKeyHex)\n            .getOrThrow()\n\n        // Step 5: Create and return SEAL\n        val seal = Seal(\n            id = generateSealId(),\n            messageCount = messages.size,\n            merkleRoot = merkleRoot,\n            messageHashes = messageHashes,\n            timestamp = System.currentTimeMillis(),\n            creatorPublicKey = creatorPublicKeyHex,\n            signature = signature,\n            verified = false,\n            tampered = false,\n            createdAt = Date()\n        )\n\n        Timber.d(\"SEAL created: ${seal.id}\")\n        Result.success(seal)\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to create SEAL\")\n        Result.failure(e)\n    }\n\n    /**\n     * Verify a SEAL\n     * Returns whether the SEAL is valid and whether it has been tampered with\n     */\n    fun verifySeal(seal: Seal): Result<SealVerification> = try {\n        Timber.d(\"Verifying SEAL: ${seal.id}\")\n\n        // Step 1: Rebuild Merkle tree from stored hashes\n        val rebuiltMerkleRoot = buildMerkleTree(seal.messageHashes)\n            ?: throw Exception(\"Failed to rebuild Merkle tree\")\n\n        // Step 2: Check if Merkle root matches\n        val merkleRootValid = rebuiltMerkleRoot == seal.merkleRoot\n        Timber.d(\"Merkle root valid: $merkleRootValid\")\n\n        // Step 3: Verify signature\n        val sealMetadata = SealMetadata(\n            messageCount = seal.messageCount,\n            merkleRoot = seal.merkleRoot,\n            timestamp = seal.timestamp,\n            messageHashes = seal.messageHashes\n        )\n        val metadataJson = sealMetadata.toJson()\n        val signatureValid = crypto.verify(\n            metadataJson.toByteArray(),\n            seal.signature,\n            seal.creatorPublicKey\n        ).getOrThrow()\n        Timber.d(\"Signature valid: $signatureValid\")\n\n        // Step 4: Determine overall validity\n        val isTampered = !merkleRootValid || !signatureValid\n        val isValid = merkleRootValid && signatureValid\n\n        val verification = SealVerification(\n            sealId = seal.id,\n            isValid = isValid,\n            isTampered = isTampered,\n            merkleRootValid = merkleRootValid,\n            signatureValid = signatureValid,\n            verifiedAt = Date(),\n            details = mapOf(\n                \"messageCount\" to seal.messageCount.toString(),\n                \"merkleRoot\" to seal.merkleRoot,\n                \"timestamp\" to seal.timestamp.toString()\n            )\n        )\n\n        Timber.d(\"SEAL verification complete: valid=$isValid, tampered=$isTampered\")\n        Result.success(verification)\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to verify SEAL\")\n        Result.failure(e)\n    }\n\n    /**\n     * Build Merkle tree from message hashes\n     * Each level combines two hashes using BLAKE2b\n     */\n    private fun buildMerkleTree(hashes: List<String>): String? = try {\n        if (hashes.isEmpty()) return null\n        if (hashes.size == 1) return hashes[0]\n\n        var currentLevel = hashes.toMutableList()\n        var level = 0\n\n        while (currentLevel.size > 1) {\n            val nextLevel = mutableListOf<String>()\n            \n            for (i in currentLevel.indices step 2) {\n                val left = currentLevel[i]\n                val right = if (i + 1 < currentLevel.size) {\n                    currentLevel[i + 1]\n                } else {\n                    left  // Duplicate if odd number\n                }\n\n                // Combine hashes\n                val combined = (left + right).toByteArray()\n                val parentHash = crypto.hash(combined).getOrNull()\n                    ?: throw Exception(\"Failed to hash combined hashes\")\n                nextLevel.add(parentHash)\n            }\n            \n            currentLevel = nextLevel\n            level++\n            Timber.d(\"Merkle tree level $level: ${currentLevel.size} nodes\")\n        }\n\n        currentLevel.firstOrNull()\n    } catch (e: Exception) {\n        Timber.e(e, \"Failed to build Merkle tree\")\n        null\n    }\n\n    private fun generateSealId(): String {\n        val timestamp = System.currentTimeMillis()\n        val random = (0..9999).random()\n        return \"SEAL-${timestamp}-${random}\"\n    }\n}\n\ndata class SealMetadata(\n    val messageCount: Int,\n    val merkleRoot: String,\n    val timestamp: Long,\n    val messageHashes: List<String>\n) {\n    fun toJson(): String {\n        return \"\"\"\n            {\"messageCount\":$messageCount,\"merkleRoot\":\"$merkleRoot\",\"timestamp\":$timestamp,\"messageHashes\":${messageHashes.joinToString(\",\", \"[\", \"]\") { \"\\\"$it\\\"\" }}}\n        \"\"\".trim()\n    }\n}\n\ndata class Seal(\n    val id: String,\n    val messageCount: Int,\n    val merkleRoot: String,\n    val messageHashes: List<String>,\n    val timestamp: Long,\n    val creatorPublicKey: String,\n    val signature: String,\n    val verified: Boolean,\n    val tampered: Boolean,\n    val createdAt: Date\n)\n\ndata class SealVerification(\n    val sealId: String,\n    val isValid: Boolean,\n    val isTampered: Boolean,\n    val merkleRootValid: Boolean,\n    val signatureValid: Boolean,\n    val verifiedAt: Date,\n    val details: Map<String, String>\n)\n"
