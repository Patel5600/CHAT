package com.seal.chat.crypto\n\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertFalse\nimport kotlin.test.assertNotNull\nimport kotlin.test.assertTrue\n\n/**\n * ACTUAL unit tests that verify Libsodium crypto works\n */\nclass SodiumCryptoTest {\n\n    private lateinit var crypto: SodiumCrypto\n\n    @Before\n    fun setup() {\n        crypto = SodiumCrypto()\n    }\n\n    @Test\n    fun testGenerateSigningKeyPair() {\n        // Act\n        val result = crypto.generateSigningKeyPair()\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val keyPair = result.getOrNull()\n        assertNotNull(keyPair)\n        assertTrue(keyPair.publicKey.isNotEmpty())\n        assertTrue(keyPair.secretKey.isNotEmpty())\n        assertTrue(keyPair.publicKey.length > 50)  // Ed25519 public key is 64 hex chars\n    }\n\n    @Test\n    fun testGenerateEncryptionKeyPair() {\n        // Act\n        val result = crypto.generateEncryptionKeyPair()\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val keyPair = result.getOrNull()\n        assertNotNull(keyPair)\n        assertTrue(keyPair.publicKey.isNotEmpty())\n        assertTrue(keyPair.secretKey.isNotEmpty())\n    }\n\n    @Test\n    fun testSignAndVerify() {\n        // Arrange\n        val message = \"Test message for signing\".toByteArray()\n        val signingKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(signingKeyPair)\n\n        // Act\n        val signResult = crypto.sign(message, signingKeyPair.secretKey)\n        val signature = signResult.getOrNull()\n        assertNotNull(signature)\n\n        val verifyResult = crypto.verify(message, signature, signingKeyPair.publicKey)\n\n        // Assert\n        assertTrue(signResult.isSuccess)\n        assertTrue(verifyResult.isSuccess)\n        assertTrue(verifyResult.getOrNull() ?: false)\n    }\n\n    @Test\n    fun testSignatureVerificationFailsWithWrongMessage() {\n        // Arrange\n        val message = \"Original message\".toByteArray()\n        val wrongMessage = \"Different message\".toByteArray()\n        val signingKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(signingKeyPair)\n\n        val signature = crypto.sign(message, signingKeyPair.secretKey).getOrNull()\n        assertNotNull(signature)\n\n        // Act\n        val verifyResult = crypto.verify(wrongMessage, signature, signingKeyPair.publicKey)\n\n        // Assert\n        assertTrue(verifyResult.isSuccess)\n        assertFalse(verifyResult.getOrNull() ?: true)\n    }\n\n    @Test\n    fun testEncryptAndDecrypt() {\n        // Arrange\n        val plaintext = \"Secret message\"\n        val key = crypto.generateKey()\n        val nonce = crypto.generateNonce()\n\n        // Act\n        val encryptResult = crypto.encrypt(plaintext, nonce, key)\n        val encryptedData = encryptResult.getOrNull()\n        assertNotNull(encryptedData)\n\n        val decryptResult = crypto.decrypt(encryptedData.ciphertext, encryptedData.nonce, key)\n        val decrypted = decryptResult.getOrNull()\n\n        // Assert\n        assertTrue(encryptResult.isSuccess)\n        assertTrue(decryptResult.isSuccess)\n        assertEquals(plaintext, decrypted)\n    }\n\n    @Test\n    fun testDecryptionFailsWithWrongKey() {\n        // Arrange\n        val plaintext = \"Secret message\"\n        val key = crypto.generateKey()\n        val wrongKey = crypto.generateKey()\n        val nonce = crypto.generateNonce()\n\n        val encryptedData = crypto.encrypt(plaintext, nonce, key).getOrNull()\n        assertNotNull(encryptedData)\n\n        // Act\n        val decryptResult = crypto.decrypt(encryptedData.ciphertext, encryptedData.nonce, wrongKey)\n\n        // Assert\n        assertTrue(decryptResult.isFailure)\n    }\n\n    @Test\n    fun testHash() {\n        // Arrange\n        val data = \"Test data\".toByteArray()\n\n        // Act\n        val result = crypto.hash(data)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val hash = result.getOrNull()\n        assertNotNull(hash)\n        assertTrue(hash.isNotEmpty())\n    }\n\n    @Test\n    fun testHashConsistency() {\n        // Arrange\n        val data = \"Test data\".toByteArray()\n\n        // Act\n        val hash1 = crypto.hash(data).getOrNull()\n        val hash2 = crypto.hash(data).getOrNull()\n\n        // Assert\n        assertEquals(hash1, hash2)\n    }\n\n    @Test\n    fun testHashDifference() {\n        // Arrange\n        val data1 = \"Test data 1\".toByteArray()\n        val data2 = \"Test data 2\".toByteArray()\n\n        // Act\n        val hash1 = crypto.hash(data1).getOrNull()\n        val hash2 = crypto.hash(data2).getOrNull()\n\n        // Assert\n        assertNotNull(hash1)\n        assertNotNull(hash2)\n        assertFalse(hash1 == hash2)\n    }\n}\n"
