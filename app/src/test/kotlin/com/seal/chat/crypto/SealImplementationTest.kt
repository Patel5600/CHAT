package com.seal.chat.crypto\n\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertFalse\nimport kotlin.test.assertNotNull\nimport kotlin.test.assertTrue\n\n/**\n * ACTUAL tests that verify SEAL creation and verification works\n */\nclass SealImplementationTest {\n\n    private lateinit var crypto: SodiumCrypto\n    private lateinit var seal: SealImplementation\n\n    @Before\n    fun setup() {\n        crypto = SodiumCrypto()\n        seal = SealImplementation(crypto)\n    }\n\n    @Test\n    fun testCreateSealWithSingleMessage() {\n        // Arrange\n        val messages = listOf(\"Hello, SEAL Chat!\")\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        // Act\n        val result = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val createdSeal = result.getOrNull()\n        assertNotNull(createdSeal)\n        assertEquals(1, createdSeal.messageCount)\n        assertTrue(createdSeal.merkleRoot.isNotEmpty())\n        assertTrue(createdSeal.signature.isNotEmpty())\n    }\n\n    @Test\n    fun testCreateSealWithMultipleMessages() {\n        // Arrange\n        val messages = listOf(\n            \"Message 1\",\n            \"Message 2\",\n            \"Message 3\",\n            \"Message 4\",\n            \"Message 5\"\n        )\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        // Act\n        val result = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val createdSeal = result.getOrNull()\n        assertNotNull(createdSeal)\n        assertEquals(5, createdSeal.messageCount)\n        assertEquals(5, createdSeal.messageHashes.size)\n    }\n\n    @Test\n    fun testVerifyValidSeal() {\n        // Arrange\n        val messages = listOf(\"Test message\")\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        val createdSeal = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n            .getOrNull()\n        assertNotNull(createdSeal)\n\n        // Act\n        val verifyResult = seal.verifySeal(createdSeal)\n\n        // Assert\n        assertTrue(verifyResult.isSuccess)\n        val verification = verifyResult.getOrNull()\n        assertNotNull(verification)\n        assertTrue(verification.isValid)\n        assertFalse(verification.isTampered)\n        assertTrue(verification.merkleRootValid)\n        assertTrue(verification.signatureValid)\n    }\n\n    @Test\n    fun testDetectTamperedMerkleRoot() {\n        // Arrange\n        val messages = listOf(\"Test message\")\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        val createdSeal = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n            .getOrNull()\n        assertNotNull(createdSeal)\n\n        // Tamper with the SEAL\n        val tamperedSeal = createdSeal.copy(\n            merkleRoot = \"tampered-merkle-root-hash\"\n        )\n\n        // Act\n        val verifyResult = seal.verifySeal(tamperedSeal)\n\n        // Assert\n        assertTrue(verifyResult.isSuccess)\n        val verification = verifyResult.getOrNull()\n        assertNotNull(verification)\n        assertFalse(verification.isValid)\n        assertTrue(verification.isTampered)\n        assertFalse(verification.merkleRootValid)\n    }\n\n    @Test\n    fun testDetectTamperedSignature() {\n        // Arrange\n        val messages = listOf(\"Test message\")\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        val createdSeal = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n            .getOrNull()\n        assertNotNull(createdSeal)\n\n        // Tamper with the signature\n        val tamperedSeal = createdSeal.copy(\n            signature = \"tampered-signature\"\n        )\n\n        // Act\n        val verifyResult = seal.verifySeal(tamperedSeal)\n\n        // Assert\n        assertTrue(verifyResult.isSuccess)\n        val verification = verifyResult.getOrNull()\n        assertNotNull(verification)\n        assertFalse(verification.isValid)\n        assertTrue(verification.isTampered)\n        assertFalse(verification.signatureValid)\n    }\n\n    @Test\n    fun testMerkleTreeWithManyMessages() {\n        // Arrange\n        val messages = (1..100).map { \"Message $it\" }\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        // Act\n        val result = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n        val createdSeal = result.getOrNull()\n        val verifyResult = seal.verifySeal(createdSeal!!)\n\n        // Assert\n        assertTrue(result.isSuccess)\n        assertEquals(100, createdSeal.messageCount)\n        assertTrue(verifyResult.isSuccess)\n        assertTrue(verifyResult.getOrNull()?.isValid ?: false)\n    }\n\n    @Test\n    fun testSealIdUniqueness() {\n        // Arrange\n        val messages = listOf(\"Test message\")\n        val keyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(keyPair)\n\n        // Act\n        val seal1 = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n            .getOrNull()\n        val seal2 = seal.createSeal(messages, keyPair.publicKey, keyPair.secretKey)\n            .getOrNull()\n\n        // Assert\n        assertNotNull(seal1)\n        assertNotNull(seal2)\n        assertFalse(seal1.id == seal2.id)  // Different SEALs should have different IDs\n    }\n}\n"
