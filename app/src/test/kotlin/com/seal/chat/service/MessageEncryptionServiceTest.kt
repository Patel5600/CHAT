package com.seal.chat.service\n\nimport com.seal.chat.crypto.SodiumCrypto\nimport org.junit.Before\nimport org.junit.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertFalse\nimport kotlin.test.assertNotNull\nimport kotlin.test.assertTrue\n\n/**\n * ACTUAL tests for message encryption/decryption\n */\nclass MessageEncryptionServiceTest {\n\n    private lateinit var crypto: SodiumCrypto\n    private lateinit var service: MessageEncryptionService\n\n    @Before\n    fun setup() {\n        crypto = SodiumCrypto()\n        service = MessageEncryptionService(crypto)\n    }\n\n    @Test\n    fun testEncryptMessage() {\n        // Arrange\n        val plaintext = \"Hello, SEAL Chat!\"\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        // Act\n        val result = service.encryptMessage(\n            plaintext,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        )\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val encrypted = result.getOrNull()\n        assertNotNull(encrypted)\n        assertTrue(encrypted.ciphertext.isNotEmpty())\n        assertTrue(encrypted.nonce.isNotEmpty())\n        assertTrue(encrypted.ephemeralKey.isNotEmpty())\n        assertTrue(encrypted.messageHash.isNotEmpty())\n    }\n\n    @Test\n    fun testEncryptAndDecryptMessage() {\n        // Arrange\n        val plaintext = \"Secret message content\"\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        // Encrypt\n        val encrypted = service.encryptMessage(\n            plaintext,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        ).getOrNull()\n        assertNotNull(encrypted)\n\n        // Act - Decrypt\n        val decryptResult = service.decryptMessage(\n            encrypted,\n            recipientKeyPair.secretKey\n        )\n\n        // Assert\n        assertTrue(decryptResult.isSuccess)\n        val decrypted = decryptResult.getOrNull()\n        assertNotNull(decrypted)\n        assertEquals(plaintext, decrypted.plaintext)\n        assertTrue(decrypted.hashValid)\n    }\n\n    @Test\n    fun testEncryptMultipleMessages() {\n        // Arrange\n        val plaintexts = listOf(\n            \"Message 1\",\n            \"Message 2\",\n            \"Message 3\"\n        )\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        // Act\n        val result = service.encryptMessages(\n            plaintexts,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        )\n\n        // Assert\n        assertTrue(result.isSuccess)\n        val encrypted = result.getOrNull()\n        assertNotNull(encrypted)\n        assertEquals(3, encrypted.size)\n        encrypted.forEach { msg ->\n            assertTrue(msg.ciphertext.isNotEmpty())\n            assertTrue(msg.nonce.isNotEmpty())\n        }\n    }\n\n    @Test\n    fun testDecryptMultipleMessages() {\n        // Arrange\n        val plaintexts = listOf(\n            \"Message 1\",\n            \"Message 2\",\n            \"Message 3\"\n        )\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        val encrypted = service.encryptMessages(\n            plaintexts,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        ).getOrNull()\n        assertNotNull(encrypted)\n\n        // Act\n        val decryptResult = service.decryptMessages(\n            encrypted,\n            recipientKeyPair.secretKey\n        )\n\n        // Assert\n        assertTrue(decryptResult.isSuccess)\n        val decrypted = decryptResult.getOrNull()\n        assertNotNull(decrypted)\n        assertEquals(3, decrypted.size)\n        decrypted.forEachIndexed { index, msg ->\n            assertEquals(plaintexts[index], msg.plaintext)\n            assertTrue(msg.hashValid)\n        }\n    }\n\n    @Test\n    fun testMessageHashValidation() {\n        // Arrange\n        val plaintext = \"Test message\"\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        var encrypted = service.encryptMessage(\n            plaintext,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        ).getOrNull()\n        assertNotNull(encrypted)\n\n        // Tamper with the hash\n        encrypted = encrypted.copy(messageHash = \"tampered-hash\")\n\n        // Act\n        val decryptResult = service.decryptMessage(\n            encrypted,\n            recipientKeyPair.secretKey\n        )\n\n        // Assert\n        assertTrue(decryptResult.isSuccess)\n        val decrypted = decryptResult.getOrNull()\n        assertNotNull(decrypted)\n        assertEquals(plaintext, decrypted.plaintext)  // Message still decrypts\n        assertFalse(decrypted.hashValid)  // But hash validation fails\n    }\n\n    @Test\n    fun testLargeMessageEncryption() {\n        // Arrange\n        val plaintext = \"x\".repeat(10000)  // 10KB message\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        // Act\n        val startTime = System.currentTimeMillis()\n        val encrypted = service.encryptMessage(\n            plaintext,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        ).getOrNull()\n        val encryptTime = System.currentTimeMillis() - startTime\n\n        // Assert\n        assertNotNull(encrypted)\n        assertTrue(encryptTime < 1000)  // Should complete in less than 1 second\n    }\n\n    @Test\n    fun testMessageIntegrity() {\n        // Arrange\n        val plaintext = \"Important message\"\n        val recipientKeyPair = crypto.generateEncryptionKeyPair().getOrNull()\n        val senderKeyPair = crypto.generateSigningKeyPair().getOrNull()\n        assertNotNull(recipientKeyPair)\n        assertNotNull(senderKeyPair)\n\n        val encrypted = service.encryptMessage(\n            plaintext,\n            recipientKeyPair.publicKey,\n            senderKeyPair.secretKey\n        ).getOrNull()\n        assertNotNull(encrypted)\n\n        // Tamper with ciphertext\n        val tamperedCiphertext = encrypted.ciphertext.dropLast(4) + \"XXXX\"\n        val tampered = encrypted.copy(ciphertext = tamperedCiphertext)\n\n        // Act\n        val decryptResult = service.decryptMessage(\n            tampered,\n            recipientKeyPair.secretKey\n        )\n\n        // Assert\n        assertTrue(decryptResult.isFailure)  // Decryption should fail\n    }\n}\n"
